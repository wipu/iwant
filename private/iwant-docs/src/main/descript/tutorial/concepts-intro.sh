subsec() {
  local TITLE=$1
  html "<h3>$TITLE</h3>"
}

humanquote() {
  TEXT=$1
  html "<p class='text'><i>"
  html "$TEXT"
  html "</i></p>"
}

doc-content() {

subsec "Declarative content of files"

humanquote '"What is this file called cool-app.jar?"'

p "If you had to answer a question like this, you would probably answer something like"

humanquote '"It is a (zip) file that contains the main (i.e. not test) java classes of cool-app."'
p "Or, the same using iwant:"
inline-snippet "coolAppJar"

humanquote '"Well, what are the java classes, then?"'
humanquote '"They are bytecode compiled from the main java files of cool-app."'
inline-snippet "coolAppMainClasses"

humanquote '"And what are the java files?"'
humanquote '"They are text files written and maintained by the developers."'
inline-snippet "coolAppMainJava"

html "<p class='text'>The answers here are examples of declarative definitions. They answer to questions that start with <i>what</i> by describing file content. The focus is in <i>nouns</i>.</p>"

html "<p class='text'>One of the main principles of iwant is that <u>build script authors and users declare <i>what</i> they want</u>. The question of <i>how</i>, the imperative part, or the <i>verbs</i>, belongs to developers of iwant and its plugins.</p>"

html "If only it wasn't so difficult to know what to want..."

subsec "Graph of static and dynamic content"

html "<p class='text'>In the java snippets above we can see two kinds of objects: <i>Sources</i> and <i>Targets</i>.</p>"

p "Generally, in the context of building, a source is a file that is directly edited by the developers of the project. And a target is a file that is (automatically) derived from other files. (Note that this differs from the compiler terminology, where compilers consume sources and produce binaries. Using the build terminology, the \"source\" files consumed by a compiler may actually be targets, if they have been generated by a code generator.)"

p "In other words, Sources are written by iwant users only, Targets by iwant only."

html "<p class='text'>In iwant terminology Sources and Targets are both called <i>Paths</i>. So, an iwant Target is a Path with content derived from other Paths. The other Paths are called the <i>ingredients</i> of the Target.</p>"

p "For example, in the snippets above we can see that the definition of coolAppMainClasses refers to coolAppMainJava, so the latter is an ingredient to the former."

subsec "Side-effects"

p "The declarative, referentially transparent nice graph of objects is a simple and powerful model that makes lazy concurrent building possible."

p "Unfortunately, the real world is more complex."

p "iwant can only guarantee correct lazy building, if it has full control over the files it has generated. But this is not always possible."

p "A remotely running deployment of an application is an example of such a build artifact. The remote machine may have crashed or some administrator may have made modifications. So even if none of the ingredients have been modified, iwant cannot know if files need to be transferred again or the application restarted."

p "One option is to just use iwant to define a script/program that does the deployment. The script is fully under iwant control, and can be refreshed and rerun whenever the user thinks it is needed."

html "<p class='text'>But iwant also supports <i>side-effects</i> directly. A side-effect is a piece of code that is executed <i>every time</i> the user requests it, unlike target code that is only executed if needed.</p>"

p "These two concepts, Target and SideEffect, are so different in nature, that both the API and the user interface of iwant make a very clear distinction between them, so there will be no surprises to the users."

subsec "Examples, please"

p "This concludes the introduction of the most important concepts. It is all still very abstract, so let's see all of them in action in the following chapters, starting from the very beginning."

}
