package net.sf.iwant.api;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import net.sf.iwant.api.model.Path;
import net.sf.iwant.api.model.Target;
import net.sf.iwant.api.model.TargetEvaluationContext;
import net.sf.iwant.coreservices.FileUtil;
import net.sf.iwant.coreservices.StreamUtil;
import net.sf.iwant.entry.Iwant;

public class ScriptGenerated extends Target {

	private final Path script;

	private ScriptGenerated(String name, Path script) {
		super(name);
		this.script = script;
	}

	public static ScriptGeneratedSpex named(String name) {
		return new ScriptGeneratedSpex(name);
	}

	public static class ScriptGeneratedSpex {

		private final String name;

		public ScriptGeneratedSpex(String name) {
			this.name = name;
		}

		public ScriptGenerated byScript(Path script) {
			return new ScriptGenerated(name, script);
		}

	}

	@Override
	public InputStream content(TargetEvaluationContext ctx) throws Exception {
		throw new UnsupportedOperationException("TODO test and implement");
	}

	@Override
	public void path(TargetEvaluationContext ctx) throws Exception {
		ExecutionEnvironment env = prepareExecutionEnvironment(ctx);
		execute(env.dir, env.cmdLine);
	}

	ExecutionEnvironment prepareExecutionEnvironment(TargetEvaluationContext ctx)
			throws IOException {
		File tmpDir = ctx.freshTemporaryDirectory();
		File tmpScript = new File(tmpDir.getCanonicalPath(), "script");

		File scriptSrc = ctx.cached(script);
		FileUtil.copyFile(scriptSrc, tmpScript);
		tmpScript.setExecutable(true);

		List<String> cmdLine = new ArrayList<String>();
		File cygwinBashExe = ctx.iwant().cygwinBashExe();
		if (cygwinBashExe != null) {
			Iwant.debugLog("ScriptGenerated", "Using wrapper for "
					+ cygwinBashExe);
			cmdLine.add(cygwinBashExe.getCanonicalPath());

			File wrapper = FileUtil
					.newTextFile(new File(tmpDir, tmpScript.getName()
							+ "-cygwinwrapper.sh"),
							cygwinBashWrapperFor(tmpScript, tmpDir));
			cmdLine.add(wrapper.getCanonicalPath());
			cmdLine.add(ctx.iwant().unixPathOf(ctx.cached(this)));
		} else {
			cmdLine.add(tmpScript.getCanonicalPath());
			cmdLine.add(ctx.cached(this).getCanonicalPath());
		}
		Iwant.debugLog("ScriptGenerated", scriptSrc, cmdLine);
		return new ExecutionEnvironment(tmpDir, cmdLine.toArray(new String[0]));
	}

	public static class ExecutionEnvironment {

		final File dir;
		final String[] cmdLine;

		public ExecutionEnvironment(File dir, String[] cmdLine) {
			this.dir = dir;
			this.cmdLine = cmdLine;
		}

	}

	private static String cygwinBashWrapperFor(File script, File runDir)
			throws IOException {
		StringBuilder sh = new StringBuilder();
		sh.append("#!/bin/bash\n");
		sh.append("SCRIPT=$(cygpath --unix -a '" + script.getCanonicalPath()
				+ "')\n");
		sh.append("RUNDIR=$(cygpath --unix -a '" + runDir.getCanonicalPath()
				+ "')\n");
		sh.append("cd \"$RUNDIR\"\n");
		sh.append("\"$SCRIPT\" \"$@\"\n");
		return sh.toString();
	}

	public static void execute(File dir, String[] cmdLine) throws IOException,
			InterruptedException {
		Process process = new ProcessBuilder(cmdLine).directory(dir)
				.redirectErrorStream(true).start();
		InputStream out = process.getInputStream();
		StreamUtil.pipe(out, System.err);

		int result = process.waitFor();
		if (result > 0) {
			throw new Iwant.IwantException(
					"Script exited with non-zero status " + result);
		}
	}

	@Override
	public List<Path> ingredients() {
		return Arrays.asList(script);
	}

	@Override
	public String contentDescriptor() {
		return getClass().getCanonicalName() + ":" + script;
	}

}
